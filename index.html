<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JJK: Cursed Technique</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
    
        #ui {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            color: #fff;
            pointer-events: none;
            z-index: 10;
        }
        
        h1 { 
            font-size: 3rem; margin: 0; letter-spacing: 10px; 
            font-weight: 900; 
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to bottom, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        #technique-name { 
            font-size: 1.2rem; color: #00ffff; margin-top: 15px; 
            font-weight: bold; letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Large Centered Camera Hub - Taller for Reel Context */
        #video-container {
            position: absolute;
            bottom: 2%;
            left: 18%;
            transform: translateX(-50%) scaleX(-1);
            width: 85vw;
            max-width: 450px;
            height: 42vh; 
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 20;
            background-color: #000; 
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
        }

        video { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        #grain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        }

        #debug-panel {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 50;
            display: none;
            min-width: 280px;
            padding: 10px 12px;
            border: 1px solid rgba(0, 255, 255, 0.35);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.75);
            color: #b9ffff;
            font: 12px/1.35 "Courier New", monospace;
            white-space: pre;
            pointer-events: none;
        }

        #bg-audio {
            display: none;
        }

        #keybind-menu {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 50;
            min-width: 240px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.62);
            color: #f0f7ff;
            font: 12px/1.35 "Courier New", monospace;
            white-space: pre;
            pointer-events: none;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
</head>
<body>
    <audio id="bg-audio" src="ost.mp3" preload="auto" loop></audio>

    <div id="grain"></div>

    <div id="ui">
        <h1>呪術廻戦</h1>
        <div id="technique-name">CURSED ENERGY</div>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
        <canvas id="output_canvas"></canvas>
    </div>
    <div id="keybind-menu"></div>
    <div id="debug-panel"></div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- Scene & Rendering ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 55;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.zIndex = '1';
    renderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(renderer.domElement);
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    composer.addPass(bloomPass);

    const COUNT = 20000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    const colors = new Float32Array(COUNT * 3);
    const sizes = new Float32Array(COUNT);
    
    const targetPositions = new Float32Array(COUNT * 3);
    const targetColors = new Float32Array(COUNT * 3);
    const targetSizes = new Float32Array(COUNT);
    const purpleExplosionSourcePositions = new Float32Array(COUNT * 3);
    const purpleExplosionSourceSizes = new Float32Array(COUNT);

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particleMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, particleMaterial);
    scene.add(particles);

    // Technique Functions 
    function getRed(i) {
        if(i < COUNT * 0.1) {
            const r = Math.random() * 9;
            const theta = Math.random() * 6.28; const phi = Math.acos(2 * Math.random() - 1);
            return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi), r: 3, g: 0.1, b: 0.1, s: 2.5 };
        } else {
            const armCount = 3; const t = (i / COUNT); 
            const angle = t * 15 + ((i % armCount) * (Math.PI * 2 / armCount));
            const radius = 2 + (t * 40); 
            return { x: radius * Math.cos(angle), y: radius * Math.sin(angle), z: (Math.random() - 0.5) * (10 * t), r: 0.8, g: 0, b: 0, s: 1.0 };
        }
    }

    function getVoid(i) {
        if (i < COUNT * 0.15) {
            const angle = Math.random() * Math.PI * 2;
            return { x: 26 * Math.cos(angle), y: 26 * Math.sin(angle), z: (Math.random()-0.5) * 1, r: 1, g: 1, b: 1, s: 2.5 };
        } else {
            const radius = 30 + Math.random() * 90;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            return { x: radius * Math.sin(phi) * Math.cos(theta), y: radius * Math.sin(phi) * Math.sin(theta), z: radius * Math.cos(phi), r: 0.1, g: 0.6, b: 1.0, s: 0.7 };
        }
    }

    function getPurple(i) {
        if (Math.random() > 0.8) return { x: (Math.random() - 0.5) * 100, y: (Math.random() - 0.5) * 100, z: (Math.random() - 0.5) * 100, r: 0.5, g: 0.5, b: 0.7, s: 0.8 };
        const r = 20; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
        return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi), r: 0.6, g: 0.5, b: 1.0, s: 2.5 };
    }

    function getShrine(i) {
        const total = COUNT;
        if (i < total * 0.3) return { x: (Math.random()-0.5)*80, y: -15, z: (Math.random()-0.5)*80, r: 0.4, g: 0, b: 0, s: 0.8 };
        else if (i < total * 0.4) {
            const px = ((i%4)<2?1:-1)*12; const pz = ((i%4)%2==0?1:-1)*8;
            return { x: px+(Math.random()-0.5)*2, y: -15+Math.random()*30, z: pz+(Math.random()-0.5)*2, r: 0.2, g: 0.2, b: 0.2, s: 0.6 };
        } else if (i < total * 0.6) {
            const t = Math.random() * Math.PI * 2; const rad = Math.random() * 30;
            const curve = Math.pow(rad/30, 2) * 10; 
            return { x: rad*Math.cos(t), y: 15 - curve + (Math.random()*2), z: rad*Math.sin(t)*0.6, r: 0.6, g: 0, b: 0, s: 0.6 };
        } else return { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
    }

    // Hand Tracking
    // --- Gesture Tuning Knobs (safe to change) ---
    // Keep tuning changes in this object. Core logic below should stay stable unless you are rewriting detection behavior.
    const TUNING = {
        smoothingAlpha: 0.20, // Higher reacts faster; lower is more stable.
        enterThreshold: 0.75, // Minimum smoothed score to enter a gesture.
        exitThreshold: 0.5, // If current gesture stays above this, it is held.
        switchMargin: 0.12, // Immediate switch: challenger must beat current by at least this amount.
        sustainedSwitchMs: 300, // Timed switch: if a challenger stays stronger for this long, it can override.
        sustainedSwitchMargin: 0.03, // Minimum lead required for the timed override path.

        purpleExplosionDurationMs: 4000, // How long the Purple explosion impulse lasts.
        purpleExplosionMaxDistance: 100, // Total outward travel from the live Purple target shape.
        purpleExplosionBloomBoost: 3, // Temporary extra bloom added on top of base technique bloom.
        postExplosionNeutralMs: 1000 // Force neutral for this long after the explosion completes.
    };

    // --- Hand Tracking Core (avoid changing unless logic changes are intended) ---
    let currentTech = 'neutral';
    let purpleEnteredAtMs = -Infinity;
    let purpleFlickEligibleUntilMs = 0;
    let shakeIntensity = 0;
    const FLICK = {
        purpleArmMs: 1000,
        flickOnlyWindowMs: 280,
        maxWindowMs: 220,
        minLagMs: 45,
        minDisplacement: 0.045,
        maxDisplacement: 0.13,
        minSpeed: 0.9,
        maxSpeed: 2.2,
        minStraightness: 0.65,
        maxStraightness: 0.92,
        triggerScore: 0.78,
        pulseMs: 150,
        refractoryMs: 220
    };
    const videoElement = document.querySelector('.input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    let glowColor = '#00ffff';
    const GESTURES = ['neutral', 'red', 'void', 'purple', 'shrine', 'flick'];
    const ACTIVE_GESTURES = ['red', 'void', 'purple', 'shrine', 'flick'];
    const smoothedScores = { neutral: 1, red: 0, void: 0, purple: 0, shrine: 0, flick: 0 };
    const rawScores = { neutral: 1, red: 0, void: 0, purple: 0, shrine: 0, flick: 0 };
    let challengerGesture = null;
    let challengerSinceMs = 0;
    let frameFlickScore = 0;
    let purpleExplosionUntilMs = 0;
    let lastPurpleExplosionMs = -Infinity;
    let flickLockUntilMs = 0;
    let flickPulseUntilMs = 0;
    let lastFlickTriggerMs = -Infinity;
    let pendingPurpleExitFlick = false;
    let neutralLockUntilMs = 0;
    let baseBloomStrength = 1.0;
    const PURPLE_EXPLOSION_COLOR = { r: 0.6, g: 0.5, b: 1.0 };
    const flickDetectorByHand = {};
    const debugPanel = document.getElementById('debug-panel');
    const keybindMenu = document.getElementById('keybind-menu');
    const musicAudio = document.getElementById('bg-audio');
    let debugEnabled = new URLSearchParams(window.location.search).get('debug') === '1';
    let musicEnabled = false;
    let keybindMenuVisible = true;
    const KEYBINDS = { debug: 'D', music: 'M', menu: 'K' };

    function clamp01(v) {
        return Math.min(1, Math.max(0, v));
    }

    function computeHandScores(lm) {
        const isUp = (tip, pip) => lm[tip].y < lm[pip].y;
        const indexUp = isUp(8, 6) ? 1 : 0;
        const middleUp = isUp(12, 10) ? 1 : 0;
        const ringUp = isUp(16, 14) ? 1 : 0;
        const pinkyUp = isUp(20, 18) ? 1 : 0;

        const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
        const pinchScore = pinch < 0.04 ? 1 : 0; // Original hardcoded purple pinch rule.

        const purple = pinchScore;
        const shrine = clamp01(0.25 * (indexUp + middleUp + ringUp + pinkyUp));
        const voidScore = clamp01((0.45 * indexUp) + (0.45 * middleUp) + (0.10 * (1 - ringUp)));
        const redBase = clamp01((0.65 * indexUp) + (0.20 * (1 - middleUp)) + (0.10 * (1 - ringUp)) + (0.05 * (1 - pinkyUp)));
        const red = clamp01(redBase * (1 - (0.70 * middleUp)));

        const pinchSuppression = 1 - (pinchScore * 0.45);
        return {
            red: clamp01(red * pinchSuppression),
            void: clamp01(voidScore * pinchSuppression),
            purple: purple,
            shrine: clamp01(shrine * (1 - (pinchScore * 0.25)))
        };
    }

    function computeFrameScores(results, nowMs) {
        const frameScores = { neutral: 1, red: 0, void: 0, purple: 0, shrine: 0, flick: 0 };
        frameFlickScore = 0;
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return frameScores;

        results.multiHandLandmarks.forEach((lm, handIdx) => {
            drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, { color: glowColor, lineWidth: 5 });
            drawLandmarks(canvasCtx, lm, { color: '#fff', lineWidth: 1, radius: 2 });

            const handScores = computeHandScores(lm);
            ACTIVE_GESTURES.forEach((tech) => {
                if (!Object.prototype.hasOwnProperty.call(handScores, tech)) return;
                frameScores[tech] = Math.max(frameScores[tech], handScores[tech]);
            });

            // Flick detection: wrist-relative motion over a short window with straightness filtering.
            const handLabel = results.multiHandedness?.[handIdx]?.label ?? `hand_${handIdx}`;
            const wrist = lm[0];
            const tip = lm[8];
            const relX = tip.x - wrist.x;
            const relY = tip.y - wrist.y;
            const indexUp = lm[8].y < lm[6].y;

            const detector = flickDetectorByHand[handLabel] || { history: [] };
            const history = detector.history;
            history.push({ x: relX, y: relY, t: nowMs });

            while (history.length > 0 && (nowMs - history[0].t) > FLICK.maxWindowMs) {
                history.shift();
            }

            let baseline = null;
            for (let i = history.length - 1; i >= 0; i--) {
                const sample = history[i];
                if ((nowMs - sample.t) >= FLICK.minLagMs) {
                    baseline = sample;
                    break;
                }
            }
            if (!baseline && history.length > 0) {
                baseline = history[0];
            }

            if (baseline) {
                const dtSec = Math.max((nowMs - baseline.t) / 1000, 1 / 120);
                const dx = relX - baseline.x;
                const dy = relY - baseline.y;
                const displacement = Math.hypot(dx, dy);
                const speed = displacement / dtSec;

                let pathLength = 0;
                for (let i = 1; i < history.length; i++) {
                    pathLength += Math.hypot(history[i].x - history[i - 1].x, history[i].y - history[i - 1].y);
                }
                const straightness = pathLength > 0.0001 ? (displacement / pathLength) : 0;

                const speedScore = clamp01((speed - FLICK.minSpeed) / (FLICK.maxSpeed - FLICK.minSpeed));
                const dispScore = clamp01((displacement - FLICK.minDisplacement) / (FLICK.maxDisplacement - FLICK.minDisplacement));
                const straightScore = clamp01((straightness - FLICK.minStraightness) / (FLICK.maxStraightness - FLICK.minStraightness));
                let handFlickScore = (0.5 * speedScore) + (0.35 * dispScore) + (0.15 * straightScore);
                if (!indexUp) handFlickScore *= 0.7;
                frameFlickScore = Math.max(frameFlickScore, handFlickScore);

                const flickTriggered = handFlickScore >= FLICK.triggerScore
                    && (nowMs - lastFlickTriggerMs) >= FLICK.refractoryMs;
                if (flickTriggered) {
                    lastFlickTriggerMs = nowMs;
                    flickPulseUntilMs = nowMs + FLICK.pulseMs;
                }
            }
            flickDetectorByHand[handLabel] = detector;
        });

        frameScores.flick = nowMs <= flickPulseUntilMs ? 1 : 0;
        const maxActive = Math.max(frameScores.red, frameScores.void, frameScores.purple, frameScores.shrine, frameScores.flick);
        frameScores.neutral = clamp01(1 - maxActive);
        return frameScores;
    }

    function smoothScores(frameScores) {
        GESTURES.forEach((tech) => {
            if (tech === 'flick') {
                // Flick should be immediate; do not smooth it.
                smoothedScores[tech] = frameScores[tech];
                return;
            }
            smoothedScores[tech] += (frameScores[tech] - smoothedScores[tech]) * TUNING.smoothingAlpha;
        });
    }

    function scoreText(value) {
        return Number.isFinite(value) ? value.toFixed(3) : '0.000';
    }

    function setDebugVisibility() {
        debugPanel.style.display = debugEnabled ? 'block' : 'none';
    }

    function updateKeybindMenu() {
        if (!keybindMenuVisible) return;
        keybindMenu.textContent = [
            'Keybinds',
            `[${KEYBINDS.music}] Soundtrack: ${musicEnabled ? 'ON' : 'OFF'}`,
            `[${KEYBINDS.debug}] Debug Panel: ${debugEnabled ? 'ON' : 'OFF'}`,
            `[${KEYBINDS.menu}] This Menu: ON`
        ].join('\n');
    }

    function setMusicEnabled(enabled) {
        if (!musicAudio) {
            musicEnabled = false;
            updateKeybindMenu();
            return;
        }

        if (enabled) {
            musicAudio.volume = 0.65;
            const playPromise = musicAudio.play();
            musicEnabled = true;
            if (playPromise && typeof playPromise.catch === 'function') {
                playPromise.catch(() => {
                    musicEnabled = false;
                    updateKeybindMenu();
                });
            }
        } else {
            musicAudio.pause();
            musicEnabled = false;
        }

        updateKeybindMenu();
    }

    function setKeybindMenuVisibility(visible) {
        keybindMenuVisible = visible;
        keybindMenu.style.display = keybindMenuVisible ? 'block' : 'none';
        if (keybindMenuVisible) updateKeybindMenu();
    }

    function updateDebugPanel(nextGesture) {
        if (!debugEnabled) return;
        const nowMs = performance.now();
        const explosionLeftMs = Math.max(0, purpleExplosionUntilMs - nowMs);
        const flickPulseLeftMs = Math.max(0, flickPulseUntilMs - nowMs);
        const purpleFlickEligibleLeftMs = Math.max(0, purpleFlickEligibleUntilMs - nowMs);
        const lines = [
            'Debug (toggle: D)',
            `currentTech: ${currentTech}`,
            `nextGesture: ${nextGesture}`,
            `flickScore: ${scoreText(frameFlickScore)}`,
            `flickPulse: ${flickPulseLeftMs.toFixed(0)}ms`,
            `purpleFlickEligible: ${purpleFlickEligibleLeftMs.toFixed(0)}ms`,
            `purpleExplosion: ${explosionLeftMs.toFixed(0)}ms`,
            '',
            'gesture   raw      smooth',
            ...GESTURES.map((tech) => {
                const name = tech.padEnd(8, ' ');
                return `${name}${scoreText(rawScores[tech])}   ${scoreText(smoothedScores[tech])}`;
            })
        ];
        debugPanel.textContent = lines.join('\n');
    }

    function triggerPurpleExplosion(nowMs) {
        if ((nowMs - lastPurpleExplosionMs) < 400) return;
        lastPurpleExplosionMs = nowMs;
        purpleExplosionUntilMs = nowMs + TUNING.purpleExplosionDurationMs;
        neutralLockUntilMs = purpleExplosionUntilMs + TUNING.postExplosionNeutralMs;
    }

    function maybeTriggerPurpleExitExplosion(nextGesture, nowMs) {
        const purpleArmed = nowMs <= purpleFlickEligibleUntilMs;
        const enteringFlick = nextGesture === 'flick' && currentTech !== 'flick';
        if (!purpleArmed || !enteringFlick) return;
        flickLockUntilMs = Math.max(flickLockUntilMs, nowMs + TUNING.purpleExplosionDurationMs);
        triggerPurpleExplosion(nowMs);
    }

    function resetChallenger() {
        challengerGesture = null;
        challengerSinceMs = 0;
    }

    function commitTransition(nextGesture, nowMs) {
        resetChallenger();
        return nextGesture;
    }

    function pickGestureFromScores(nowMs) {
        if (currentTech === 'flick' && nowMs < flickLockUntilMs) {
            return 'flick';
        }
        if (nowMs >= purpleExplosionUntilMs && nowMs < neutralLockUntilMs) {
            return currentTech === 'neutral' ? 'neutral' : commitTransition('neutral', nowMs);
        }

        // Flick-only window after exiting Purple: ignore all other gestures.
        if (nowMs <= purpleFlickEligibleUntilMs && currentTech !== 'flick') {
            const flickReady = pendingPurpleExitFlick || nowMs <= flickPulseUntilMs || rawScores.flick >= 1;
            if (flickReady) {
                pendingPurpleExitFlick = false;
                return commitTransition('flick', nowMs);
            }
            if (nowMs >= purpleFlickEligibleUntilMs) pendingPurpleExitFlick = false;
            return currentTech === 'neutral' ? 'neutral' : commitTransition('neutral', nowMs);
        }

        let bestGesture = 'neutral';
        let bestScore = 0;

        ACTIVE_GESTURES.forEach((tech) => {
            // Outside flick-only window, normal gesture competition excludes flick.
            if (tech === 'flick') return;
            if (smoothedScores[tech] > bestScore) {
                bestScore = smoothedScores[tech];
                bestGesture = tech;
            }
        });

        const activeScore = currentTech === 'neutral' ? smoothedScores.neutral : smoothedScores[currentTech];

        if (currentTech !== 'neutral') {
            const challengerIsStronger = bestGesture !== currentTech
                && bestScore >= TUNING.enterThreshold
                && (bestScore - activeScore) >= TUNING.switchMargin;

            if (challengerIsStronger) {
                return commitTransition(bestGesture, nowMs);
            }

            const hasTimedChallenger = bestGesture !== currentTech
                && bestScore >= TUNING.enterThreshold
                && bestScore > activeScore;

            if (hasTimedChallenger) {
                if (challengerGesture !== bestGesture) {
                    challengerGesture = bestGesture;
                    challengerSinceMs = nowMs;
                } else {
                    const heldMs = nowMs - challengerSinceMs;
                    const timedOverrideReady = heldMs >= TUNING.sustainedSwitchMs
                        && (bestScore - activeScore) >= TUNING.sustainedSwitchMargin;
                    if (timedOverrideReady) {
                        return commitTransition(bestGesture, nowMs);
                    }
                }
            } else {
                resetChallenger();
            }

            if (activeScore >= TUNING.exitThreshold) {
                return currentTech;
            }

            return commitTransition('neutral', nowMs);
        }

        resetChallenger();
        if (bestScore < TUNING.enterThreshold) {
            return 'neutral';
        }

        return commitTransition(bestGesture, nowMs);
    }

    setDebugVisibility();
    setKeybindMenuVisibility(true);
    updateKeybindMenu();
    setMusicEnabled(false);
    window.addEventListener('keydown', (event) => {
        if (event.repeat) return;
        const key = event.key.toLowerCase();
        if (key === KEYBINDS.debug.toLowerCase()) {
            debugEnabled = !debugEnabled;
            setDebugVisibility();
            if (debugEnabled) updateDebugPanel(currentTech);
            updateKeybindMenu();
            return;
        }
        if (key === KEYBINDS.music.toLowerCase()) {
            setMusicEnabled(!musicEnabled);
            return;
        }
        if (key === KEYBINDS.menu.toLowerCase()) {
            setKeybindMenuVisibility(!keybindMenuVisible);
        }
    });

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7 });

    hands.onResults((results) => {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        const nowMs = performance.now();

        const frameScores = computeFrameScores(results, nowMs);
        const purpleArmedNow = currentTech === 'purple' && (nowMs - purpleEnteredAtMs) >= FLICK.purpleArmMs;
        if (purpleArmedNow && (frameScores.flick >= 1 || nowMs <= flickPulseUntilMs)) {
            // Preserve flick intent even if the hand settles into another symbol right after the flick motion.
            pendingPurpleExitFlick = true;
        }
        const maxActive = Math.max(frameScores.red, frameScores.void, frameScores.purple, frameScores.shrine, frameScores.flick);
        frameScores.neutral = clamp01(1 - maxActive);
        GESTURES.forEach((tech) => { rawScores[tech] = frameScores[tech]; });
        smoothScores(frameScores);
        const nextGesture = pickGestureFromScores(nowMs);
        maybeTriggerPurpleExitExplosion(nextGesture, nowMs);
        updateState(nextGesture);
        updateDebugPanel(nextGesture);
    });

    function updateState(tech, force = false) {
        if(!force && currentTech === tech) return;
        const prevTech = currentTech;
        const nowMs = performance.now();
        currentTech = tech;
        if (currentTech === 'flick') {
            // Safety: if flick was manually entered, still lock it for a full release window.
            flickLockUntilMs = Math.max(flickLockUntilMs, nowMs + TUNING.purpleExplosionDurationMs);
        }
        if (currentTech === 'purple') {
            purpleEnteredAtMs = nowMs;
            purpleFlickEligibleUntilMs = 0;
            pendingPurpleExitFlick = false;
        } else if (prevTech === 'purple') {
            // After exiting Purple, open a short flick-only window if Purple was held long enough.
            const purpleHeldLongEnough = (nowMs - purpleEnteredAtMs) >= FLICK.purpleArmMs;
            purpleFlickEligibleUntilMs = purpleHeldLongEnough ? (nowMs + FLICK.flickOnlyWindowMs) : 0;
            if (!purpleHeldLongEnough) pendingPurpleExitFlick = false;
        } else if (nowMs > purpleFlickEligibleUntilMs && currentTech !== 'flick') {
            pendingPurpleExitFlick = false;
        }
        const nameEl = document.getElementById('technique-name');
        shakeIntensity = tech !== 'neutral' ? 0.4 : 0;

        if(tech === 'shrine') { glowColor = '#ff0000'; nameEl.innerText = "Domain Expansion: Malevolent Shrine"; baseBloomStrength = 2.5; }
        else if(tech === 'purple') { glowColor = '#bb00ff'; nameEl.innerText = "Secret Technique: Hollow Purple"; baseBloomStrength = 4.0; }
        else if(tech === 'void') { glowColor = '#00ffff'; nameEl.innerText = "Domain Expansion: Infinite Void"; baseBloomStrength = 2.0; }
        else if(tech === 'red') { glowColor = '#ff3333'; nameEl.innerText = "Reverse Cursed Technique: Red"; baseBloomStrength = 2.5; }
        else if(tech === 'flick') { glowColor = '#bb88ff'; nameEl.innerText = "Release Flick"; baseBloomStrength = 1.4; }
        else { glowColor = '#00ffff'; nameEl.innerText = "Neutral State"; baseBloomStrength = 1.0; }
        bloomPass.strength = baseBloomStrength;

        if (tech === 'flick') {
            // Keep current Purple-derived target shape while explosion animation runs.
            return;
        }

        for(let i=0; i<COUNT; i++) {
            let p;
            if(tech === 'neutral') {
                if(i < COUNT * 0.05) {
                    const r = 15 + Math.random()*20; const t = Math.random()*6.28; const ph = Math.random()*3.14;
                    p = { x: r*Math.sin(ph)*Math.cos(t), y: r*Math.sin(ph)*Math.sin(t), z: r*Math.cos(ph), r: 0.1, g: 0.1, b: 0.2, s: 0.4 };
                } else p = { x:0, y:0, z:0, r:0, g:0, b:0, s:0 };
            }
            else if(tech === 'red') p = getRed(i);
            else if(tech === 'void') p = getVoid(i);
            else if(tech === 'purple') p = getPurple(i);
            else if(tech === 'shrine') p = getShrine(i);
            
            targetPositions[i*3] = p.x; targetPositions[i*3+1] = p.y; targetPositions[i*3+2] = p.z;
            targetColors[i*3] = p.r; targetColors[i*3+1] = p.g; targetColors[i*3+2] = p.b;
            targetSizes[i] = p.s;
            if (tech === 'purple') {
                // Explosion should always originate from a Purple shape, not from whatever symbol is active later.
                purpleExplosionSourcePositions[i*3] = p.x;
                purpleExplosionSourcePositions[i*3+1] = p.y;
                purpleExplosionSourcePositions[i*3+2] = p.z;
                purpleExplosionSourceSizes[i] = p.s;
            }
        }
    }

    updateState('neutral', true);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            await hands.send({image: videoElement});
        }, width: 640, height: 480
    });
    cameraUtils.start();

    // Animation
    function animate() {
        requestAnimationFrame(animate);

        const pos = particles.geometry.attributes.position.array;
        const col = particles.geometry.attributes.color.array;
        const siz = particles.geometry.attributes.size.array;

        for(let i=0; i<COUNT*3; i++) {
            pos[i] += (targetPositions[i] - pos[i]) * 0.1;
            col[i] += (targetColors[i] - col[i]) * 0.1;
        }
        for(let i=0; i<COUNT; i++) siz[i] += (targetSizes[i] - siz[i]) * 0.1;

        const nowMs = performance.now();
        const explosionTimeLeftMs = purpleExplosionUntilMs - nowMs;
        if (explosionTimeLeftMs > 0) {
            const life = explosionTimeLeftMs / TUNING.purpleExplosionDurationMs;
            const progress = 1 - life;
            const blastDistance = TUNING.purpleExplosionMaxDistance * (1 - Math.pow(1 - progress, 1.9));
            for(let i=0; i<COUNT; i++) {
                const idx = i * 3;
                let sx = purpleExplosionSourcePositions[idx];
                let sy = purpleExplosionSourcePositions[idx + 1];
                let sz = purpleExplosionSourcePositions[idx + 2];
                if (sx === 0 && sy === 0 && sz === 0) {
                    sx = targetPositions[idx];
                    sy = targetPositions[idx + 1];
                    sz = targetPositions[idx + 2];
                }
                let dx = sx;
                let dy = sy;
                let dz = sz;
                let len = Math.hypot(dx, dy, dz);
                if (len < 0.001) {
                    const a = (i / COUNT) * Math.PI * 2;
                    const b = ((i * 13) % COUNT) / COUNT * Math.PI;
                    dx = Math.cos(a) * Math.sin(b);
                    dy = Math.sin(a) * Math.sin(b);
                    dz = Math.cos(b);
                    len = Math.max(Math.hypot(dx, dy, dz), 0.001);
                }
                const variance = 0.84 + ((i % 9) * 0.035);
                const travel = blastDistance * variance;
                pos[idx] = sx + ((dx / len) * travel);
                pos[idx + 1] = sy + ((dy / len) * travel);
                pos[idx + 2] = sz + ((dz / len) * travel);
                col[idx] = PURPLE_EXPLOSION_COLOR.r;
                col[idx + 1] = PURPLE_EXPLOSION_COLOR.g;
                col[idx + 2] = PURPLE_EXPLOSION_COLOR.b;
                siz[i] = purpleExplosionSourceSizes[i] > 0 ? purpleExplosionSourceSizes[i] : siz[i];
            }
            const bloomKick = TUNING.purpleExplosionBloomBoost * life;
            bloomPass.strength = baseBloomStrength + bloomKick;
            const effectiveShake = Math.max(shakeIntensity, 0.95 * life);
            renderer.domElement.style.transform = `translate(${(Math.random()-0.5)*effectiveShake*40}px, ${(Math.random()-0.5)*effectiveShake*40}px)`;
        } else {
            bloomPass.strength = baseBloomStrength;
            if (shakeIntensity > 0) {
                renderer.domElement.style.transform = `translate(${(Math.random()-0.5)*shakeIntensity*40}px, ${(Math.random()-0.5)*shakeIntensity*40}px)`;
            } else {
                renderer.domElement.style.transform = 'translate(0,0)';
            }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        particles.geometry.attributes.size.needsUpdate = true;
        
        // UPDATED ROTATION LOGIC: Locking rotation for Shrine
        if(currentTech === 'red') {
            particles.rotation.z -= 0.1;
        } else if (currentTech === 'purple') {
            particles.rotation.z += 0.2; 
            particles.rotation.y += 0.05;
        } else if (currentTech === 'shrine') {
            // FORCE UPRIGHT: Reset and freeze all rotations
            particles.rotation.set(0, 0, 0); 
        } else {
            // Default Neutral rotation
            particles.rotation.y += 0.005;
        }

        composer.render();
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
